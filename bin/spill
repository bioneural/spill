#!/usr/bin/env ruby
# frozen_string_literal: true

# spill â€” structured log reader and management tool
#
# Reads and manages a centralized SQLite log database.
#
# Subcommands:
#   spill tail [--lines N]           Last N entries (default 20), formatted
#   spill search --tool T            Filter by tool name
#   spill search --level L           Filter by level
#   spill search --since TIMESTAMP   Entries after timestamp
#   spill search --msg PATTERN       Grep message field
#   spill read                       Raw JSONL to stdout
#   spill cull                       Delete oldest 50% of entries
#
# Usage:
#   bin/spill tail
#   bin/spill tail --lines 50
#   bin/spill search --tool hooker --level error
#   bin/spill search --since 2026-02-11T00:00:00Z
#   bin/spill search --msg "sqlite3"
#   bin/spill read
#   bin/spill cull
#
# Environment:
#   SPILL_DB    Path to database (default: .state/spill/spill.db)
#
# Dependencies: ruby stdlib (json, open3), sqlite3 CLI

require 'json'
require 'open3'

DB_PATH = ENV.fetch('SPILL_DB') { File.join(Dir.pwd, '.state', 'spill', 'spill.db') }

LEVEL_COLORS = {
  'error' => "\033[31m",
  'warn'  => "\033[33m",
  'info'  => "\033[32m",
  'debug' => "\033[36m"
}.freeze
RESET = "\033[0m"

def parse_flag(args, flag)
  idx = args.index(flag)
  return nil unless idx
  args.delete_at(idx)
  args.delete_at(idx)
end

def esc(str)
  str.to_s.gsub("'", "''")
end

def sql_query(sql)
  return [] unless File.exist?(DB_PATH)
  stdout, = Open3.capture2('sqlite3', '-json', DB_PATH, stdin_data: sql, err: File::NULL)
  return [] if stdout.strip.empty?
  JSON.parse(stdout)
rescue
  []
end

def format_entry(entry)
  ts = entry['ts']&.sub(/T/, ' ')&.sub(/Z$/, '')
  level = entry['level'] || '?'
  tool = entry['tool'] || '?'
  msg = entry['msg'] || ''
  color = LEVEL_COLORS[level] || ''
  ctx = entry['ctx']
  if ctx.is_a?(String) && !ctx.empty?
    ctx = JSON.parse(ctx) rescue ctx
  end
  ctx_str = ctx.is_a?(Hash) && !ctx.empty? ? " #{ctx.inspect}" : ''
  "#{ts} #{color}%-5s#{RESET} [#{tool}] #{msg}#{ctx_str}" % level
end

def cmd_tail(args)
  n = (parse_flag(args, '--lines') || '20').to_i
  entries = sql_query("SELECT * FROM log ORDER BY id DESC LIMIT #{n};")
  entries.reverse.each { |e| puts format_entry(e) }
end

def cmd_search(args)
  tool = parse_flag(args, '--tool')
  level = parse_flag(args, '--level')
  since = parse_flag(args, '--since')
  pattern = parse_flag(args, '--msg')

  conditions = []
  conditions << "tool = '#{esc(tool)}'" if tool
  conditions << "level = '#{esc(level)}'" if level
  conditions << "ts >= '#{esc(since)}'" if since
  conditions << "msg LIKE '%#{esc(pattern)}%'" if pattern

  where = conditions.empty? ? '' : "WHERE #{conditions.join(' AND ')}"
  entries = sql_query("SELECT * FROM log #{where} ORDER BY id ASC;")

  entries.each { |e| puts format_entry(e) }
  $stderr.puts "#{entries.length} entries" if entries.length > 0
end

def cmd_read
  return unless File.exist?(DB_PATH)
  entries = sql_query("SELECT ts, tool, level, msg, pid, ctx FROM log ORDER BY id ASC;")
  entries.each do |e|
    row = { 'ts' => e['ts'], 'tool' => e['tool'], 'level' => e['level'],
            'msg' => e['msg'], 'pid' => e['pid'] }
    if e['ctx'] && !e['ctx'].to_s.empty?
      row['ctx'] = JSON.parse(e['ctx']) rescue e['ctx']
    end
    puts JSON.generate(row)
  end
end

def cmd_cull
  unless File.exist?(DB_PATH)
    $stderr.puts 'spill: nothing to cull'
    return
  end

  count_out, = Open3.capture2('sqlite3', DB_PATH,
    stdin_data: "SELECT COUNT(*) FROM log;", err: File::NULL)
  count = count_out.strip.to_i

  if count == 0
    $stderr.puts 'spill: no entries to cull'
    return
  end

  half = count / 2
  Open3.capture2('sqlite3', DB_PATH,
    stdin_data: "DELETE FROM log WHERE id IN " \
      "(SELECT id FROM log ORDER BY id ASC LIMIT #{half}); VACUUM;",
    err: File::NULL)
  $stderr.puts "spill: culled #{half} entries (#{count - half} remaining)"
end

def usage
  $stderr.puts <<~USAGE
    Usage: spill <command> [options]

    Commands:
      tail [--lines N]             Last N entries (default 20), formatted
      search [--tool T] [--level L] [--since TS] [--msg PAT]
                                   Filter entries
      read                         Raw JSONL to stdout
      cull                         Delete oldest 50% of entries and vacuum

    Environment:
      SPILL_DB   Path to database (default: .state/spill/spill.db)
  USAGE
  exit 1
end

command = ARGV.shift
case command
when 'tail'   then cmd_tail(ARGV.dup)
when 'search' then cmd_search(ARGV.dup)
when 'read'   then cmd_read
when 'cull'   then cmd_cull
else usage
end
